{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ORM::ActiveRecord The latest version of this documentation lives at https://gdonald.github.io/ORM-ActiveRecord/ . The homepage for ORM::ActiveRecord is https://github.com/gdonald/ORM-ActiveRecord . Synopsis ORM::ActiveRecord is an object-relational mapping module for Rakudo Perl 6 that mostly follows the Active Record Pattern . Example Usage 1 2 3 4 5 6 7 8 9 10 11 12 13 use User ; use Page ; my User $user = User . create ({ fname => 'Greg' }); my Page $page = Page . create ({: $user , name => 'Rakuist' }); say $user . pages . first . name ; say $page . user . fname ; my User $alfred = User . create ({ fname => 'Alfred' }); $page . update ({ user => $alfred }); say $page . user . fname Output: 1 2 3 Rakuist Greg Alfred Install ORM::ActiveRecord can be installed using the zef module installation tool: 1 zef install --/test ORM::ActiveRecord --/test is suggested because you probably don't have a test database setup. You can of course setup a test database .","title":"Home"},{"location":"#ormactiverecord","text":"The latest version of this documentation lives at https://gdonald.github.io/ORM-ActiveRecord/ . The homepage for ORM::ActiveRecord is https://github.com/gdonald/ORM-ActiveRecord .","title":"ORM::ActiveRecord"},{"location":"#synopsis","text":"ORM::ActiveRecord is an object-relational mapping module for Rakudo Perl 6 that mostly follows the Active Record Pattern .","title":"Synopsis"},{"location":"#example-usage","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 use User ; use Page ; my User $user = User . create ({ fname => 'Greg' }); my Page $page = Page . create ({: $user , name => 'Rakuist' }); say $user . pages . first . name ; say $page . user . fname ; my User $alfred = User . create ({ fname => 'Alfred' }); $page . update ({ user => $alfred }); say $page . user . fname Output: 1 2 3 Rakuist Greg Alfred","title":"Example Usage"},{"location":"#install","text":"ORM::ActiveRecord can be installed using the zef module installation tool: 1 zef install --/test ORM::ActiveRecord --/test is suggested because you probably don't have a test database setup. You can of course setup a test database .","title":"Install"},{"location":"migrations/","text":"Migrations ORM::ActiveRecord includes commands to migrate your database. Migrations include adding and removing tables as well as adding and removing columns and indexes. Migration files should contain two methods: an up and a down . The up method is the forward change you want to perform. The down method should contain what you want to happen if you decide to rollback the changes from the up method. Examples db/migrate/001-create-users.pm6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 use ORM::ActiveRecord::Migration ; class CreateUsers is Migration { method up { self . create-table: 'users' , [ fname => { : string , limit => 32 }, lname => { : string , limit => 32 } ] } method down { self . drop-table: 'users' ; } } db/migrate/002-create-pages.pm6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 use ORM::ActiveRecord::Migration ; class CreatePages is Migration { method up { self . create-table: 'pages' , [ user => { : reference }, name => { : string , limit => 32 } ] } method down { self . drop-table: 'pages' ; } } Run Migrations New migrations can be ran using the provided ar command. It its most simple form ar will run all outstanding up methods. 1 $ ar Other migration options include the ability to only migrate up or down a specific number of migrations: 1 2 3 4 $ ar up # runs all pending migrations $ ar down # resets all migrations, be careful! $ ar up:1 # runs 1 pending migrations $ ar down:2 # resets 2 previously completed migrations","title":"Migrations"},{"location":"migrations/#migrations","text":"ORM::ActiveRecord includes commands to migrate your database. Migrations include adding and removing tables as well as adding and removing columns and indexes. Migration files should contain two methods: an up and a down . The up method is the forward change you want to perform. The down method should contain what you want to happen if you decide to rollback the changes from the up method.","title":"Migrations"},{"location":"migrations/#examples","text":"db/migrate/001-create-users.pm6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 use ORM::ActiveRecord::Migration ; class CreateUsers is Migration { method up { self . create-table: 'users' , [ fname => { : string , limit => 32 }, lname => { : string , limit => 32 } ] } method down { self . drop-table: 'users' ; } } db/migrate/002-create-pages.pm6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 use ORM::ActiveRecord::Migration ; class CreatePages is Migration { method up { self . create-table: 'pages' , [ user => { : reference }, name => { : string , limit => 32 } ] } method down { self . drop-table: 'pages' ; } }","title":"Examples"},{"location":"migrations/#run-migrations","text":"New migrations can be ran using the provided ar command. It its most simple form ar will run all outstanding up methods. 1 $ ar Other migration options include the ability to only migrate up or down a specific number of migrations: 1 2 3 4 $ ar up # runs all pending migrations $ ar down # resets all migrations, be careful! $ ar up:1 # runs 1 pending migrations $ ar down:2 # resets 2 previously completed migrations","title":"Run Migrations"},{"location":"tests/","text":"Tests ORM::ActiveRecord includes a full test suite. To run it you need to first configure a local test database. Database configuration A database configuration file is expected to be at config/application.json . The format looks like this: 1 2 3 4 5 6 7 8 { \"db\" : { \"schema\" : \"public\" , \"name\" : \"ar\" , \"user\" : \"postgres\" , \"password\" : \"\" } } You can copy the config/application.json-example file to config/application.json and then change the parameters as required for your particular setup. Running with prove6 You can run the entire test suite with prove6 from TAP::Harness . 1 $ prove6 You should get output similar to this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 t/000-meta.t6 ........................... ok t/001-basic.t6 .......................... ok t/002-validate-acceptance.t6 ............ ok t/002-validate-build-save.t6 ............ ok t/002-validate-build.t6 ................. ok t/002-validate-confirmation.t6 .......... ok t/002-validate-create.t6 ................ ok t/002-validate-exclusion.t6 ............. ok t/002-validate-format.t6 ................ ok t/002-validate-inclusion.t6 ............. ok t/002-validate-integer-numericality.t6 .. ok t/002-validate-length.t6 ................ ok t/002-validate-presence-if-unless.t6 .... ok t/002-validate-presence-on-create.t6 .... ok t/002-validate-presence-on-update.t6 .... ok t/002-validate-unique-scope.t6 .......... ok t/002-validate-uniqueness.t6 ............ ok t/002-validate-update.t6 ................ ok t/003-update-save.t6 .................... ok t/004-model-custom-errors.t6 ............ ok t/004-model-dynamic-errors.t6 ........... ok t/004-model-foreign-key.t6 .............. ok t/004-model-is-dirty.t6 ................. ok t/004-model-where.t6 .................... ok t/005-callback-after-create.t6 .......... ok t/005-callback-after-save.t6 ............ ok t/005-callback-after-update.t6 .......... ok t/005-callback-before-create.t6 ......... ok t/005-callback-before-save.t6 ........... ok t/005-callback-before-update.t6 ......... ok All tests successful. Files = 30 , Tests = 220 , 15 wallclock secs Result: PASS Running a single test file You can run a single test file using Rakudo Perl 6: 1 perl6 -Ilib t/001-basic.t6 You should get output similar to this: 1 2 3 4 5 6 1 ..5 ok 1 - ok 2 - ok 3 - ok 4 - ok 5 -","title":"Tests"},{"location":"tests/#tests","text":"ORM::ActiveRecord includes a full test suite. To run it you need to first configure a local test database.","title":"Tests"},{"location":"tests/#database-configuration","text":"A database configuration file is expected to be at config/application.json . The format looks like this: 1 2 3 4 5 6 7 8 { \"db\" : { \"schema\" : \"public\" , \"name\" : \"ar\" , \"user\" : \"postgres\" , \"password\" : \"\" } } You can copy the config/application.json-example file to config/application.json and then change the parameters as required for your particular setup.","title":"Database configuration"},{"location":"tests/#running-with-prove6","text":"You can run the entire test suite with prove6 from TAP::Harness . 1 $ prove6 You should get output similar to this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 t/000-meta.t6 ........................... ok t/001-basic.t6 .......................... ok t/002-validate-acceptance.t6 ............ ok t/002-validate-build-save.t6 ............ ok t/002-validate-build.t6 ................. ok t/002-validate-confirmation.t6 .......... ok t/002-validate-create.t6 ................ ok t/002-validate-exclusion.t6 ............. ok t/002-validate-format.t6 ................ ok t/002-validate-inclusion.t6 ............. ok t/002-validate-integer-numericality.t6 .. ok t/002-validate-length.t6 ................ ok t/002-validate-presence-if-unless.t6 .... ok t/002-validate-presence-on-create.t6 .... ok t/002-validate-presence-on-update.t6 .... ok t/002-validate-unique-scope.t6 .......... ok t/002-validate-uniqueness.t6 ............ ok t/002-validate-update.t6 ................ ok t/003-update-save.t6 .................... ok t/004-model-custom-errors.t6 ............ ok t/004-model-dynamic-errors.t6 ........... ok t/004-model-foreign-key.t6 .............. ok t/004-model-is-dirty.t6 ................. ok t/004-model-where.t6 .................... ok t/005-callback-after-create.t6 .......... ok t/005-callback-after-save.t6 ............ ok t/005-callback-after-update.t6 .......... ok t/005-callback-before-create.t6 ......... ok t/005-callback-before-save.t6 ........... ok t/005-callback-before-update.t6 ......... ok All tests successful. Files = 30 , Tests = 220 , 15 wallclock secs Result: PASS","title":"Running with prove6"},{"location":"tests/#running-a-single-test-file","text":"You can run a single test file using Rakudo Perl 6: 1 perl6 -Ilib t/001-basic.t6 You should get output similar to this: 1 2 3 4 5 6 1 ..5 ok 1 - ok 2 - ok 3 - ok 4 - ok 5 -","title":"Running a single test file"},{"location":"models/callbacks/","text":"Model Callbacks ORM::ActiveRecord supports callbacks that can be performed during various life cycle events. These callbacks currently include after-create , after-save , after-update , before-create , before-save , and before-update . After Create 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 use ORM::ActiveRecord::Model ; class Log is Model {}; class Client is Model { submethod BUILD { self . validate: 'email' , { : presence }; self . after- create: -> { self . log }; } method log { my $log = self . email ~ ' was created' ; Log . create ({: $log }); } } # No logs to start with say Log . count == 0 ; # Creating a record creates a log my $client = Client . create ({ email => 'fred@aol.com' }); say Log . count == 1 ; # Updating a record does not create a log $client . email = 'barney@compuserve.net' ; $client . save ; say Log . count == 1 ; Output 1 2 3 True True True After Save 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 use ORM::ActiveRecord::Model ; class Log is Model {}; class Client is Model { submethod BUILD { self . validate: 'email' , { : presence }; self . after- save: -> { self . log }; } method log { my $log = self . email ~ ' was saved' ; Log . create ({: $log }); } } # No logs to start with say Log . count == 0 ; # Creating a record creates a log my $client = Client . create ({ email => 'fred@aol.com' }); say Log . count == 1 ; # Updating a record also creates a log $client . email = 'barney@compuserve.net' ; $client . save ; say Log . count == 2 ; Output 1 2 3 True True True After Update 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 use ORM::ActiveRecord::Model ; class Log is Model {}; class Client is Model { submethod BUILD { self . validate: 'email' , { : presence }; self . after- update: -> { self . log }; } method log { my $log = self . email ~ ' was updated' ; Log . create ({: $log }); } } # No logs to start with say Log . count == 0 ; # Creating a record does not create a log my $client = Client . create ({ email => 'fred@aol.com' }); say Log . count == 0 ; # Updating a record creates a log $client . email = 'barney@compuserve.net' ; $client . save ; say Log . count == 1 ; Output 1 2 3 True True True Before Create 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 use ORM::ActiveRecord::Model ; class Client is Model { submethod BUILD { self . validate: 'email' , { : presence }; self . before- create: -> { self . lowercase-email }; } method lowercase-email { self . email .= lc ; } } # Email is lower-cased before the record is created my $client = Client . create ({ email => 'Fred@AOL.com' }); say $client . email eq 'fred@aol.com' ; # Email is not lower-cased before the record is updated $client . email = 'BARNEY@compuserve.NET' ; $client . save ; say $client . email eq 'BARNEY@compuserve.NET' ; Output 1 2 True True Before Save 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 use ORM::ActiveRecord::Model ; class Client is Model { submethod BUILD { self . validate: 'email' , { : presence }; self . before- save: -> { self . lowercase-email }; } method lowercase-email { self . email .= lc ; } } # Email is lower-cased before the record is created my $client = Client . create ({ email => 'Fred@AOL.com' }); say $client . email eq 'fred@aol.com' ; # Email is also lower-cased before the record is updated $client . email = 'BARNEY@compuserve.NET' ; $client . save ; say $client . email eq 'barney@compuserve.net' ; Output 1 2 True True Before Update 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 use ORM::ActiveRecord::Model ; class Client is Model { submethod BUILD { self . validate: 'email' , { : presence }; self . before- update: -> { self . lowercase-email }; } method lowercase-email { self . email .= lc ; } } # Email is not lower-cased before the record is created my $client = Client . create ({ email => 'Fred@AOL.com' }); say $client . email eq 'Fred@AOL.com' ; # Email is lower-cased before the record is saved $client . save ; say $client . email eq 'fred@aol.com' ; Output 1 2 True True","title":"Callbacks"},{"location":"models/callbacks/#model-callbacks","text":"ORM::ActiveRecord supports callbacks that can be performed during various life cycle events. These callbacks currently include after-create , after-save , after-update , before-create , before-save , and before-update .","title":"Model Callbacks"},{"location":"models/callbacks/#after-create","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 use ORM::ActiveRecord::Model ; class Log is Model {}; class Client is Model { submethod BUILD { self . validate: 'email' , { : presence }; self . after- create: -> { self . log }; } method log { my $log = self . email ~ ' was created' ; Log . create ({: $log }); } } # No logs to start with say Log . count == 0 ; # Creating a record creates a log my $client = Client . create ({ email => 'fred@aol.com' }); say Log . count == 1 ; # Updating a record does not create a log $client . email = 'barney@compuserve.net' ; $client . save ; say Log . count == 1 ; Output 1 2 3 True True True","title":"After Create"},{"location":"models/callbacks/#after-save","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 use ORM::ActiveRecord::Model ; class Log is Model {}; class Client is Model { submethod BUILD { self . validate: 'email' , { : presence }; self . after- save: -> { self . log }; } method log { my $log = self . email ~ ' was saved' ; Log . create ({: $log }); } } # No logs to start with say Log . count == 0 ; # Creating a record creates a log my $client = Client . create ({ email => 'fred@aol.com' }); say Log . count == 1 ; # Updating a record also creates a log $client . email = 'barney@compuserve.net' ; $client . save ; say Log . count == 2 ; Output 1 2 3 True True True","title":"After Save"},{"location":"models/callbacks/#after-update","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 use ORM::ActiveRecord::Model ; class Log is Model {}; class Client is Model { submethod BUILD { self . validate: 'email' , { : presence }; self . after- update: -> { self . log }; } method log { my $log = self . email ~ ' was updated' ; Log . create ({: $log }); } } # No logs to start with say Log . count == 0 ; # Creating a record does not create a log my $client = Client . create ({ email => 'fred@aol.com' }); say Log . count == 0 ; # Updating a record creates a log $client . email = 'barney@compuserve.net' ; $client . save ; say Log . count == 1 ; Output 1 2 3 True True True","title":"After Update"},{"location":"models/callbacks/#before-create","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 use ORM::ActiveRecord::Model ; class Client is Model { submethod BUILD { self . validate: 'email' , { : presence }; self . before- create: -> { self . lowercase-email }; } method lowercase-email { self . email .= lc ; } } # Email is lower-cased before the record is created my $client = Client . create ({ email => 'Fred@AOL.com' }); say $client . email eq 'fred@aol.com' ; # Email is not lower-cased before the record is updated $client . email = 'BARNEY@compuserve.NET' ; $client . save ; say $client . email eq 'BARNEY@compuserve.NET' ; Output 1 2 True True","title":"Before Create"},{"location":"models/callbacks/#before-save","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 use ORM::ActiveRecord::Model ; class Client is Model { submethod BUILD { self . validate: 'email' , { : presence }; self . before- save: -> { self . lowercase-email }; } method lowercase-email { self . email .= lc ; } } # Email is lower-cased before the record is created my $client = Client . create ({ email => 'Fred@AOL.com' }); say $client . email eq 'fred@aol.com' ; # Email is also lower-cased before the record is updated $client . email = 'BARNEY@compuserve.NET' ; $client . save ; say $client . email eq 'barney@compuserve.net' ; Output 1 2 True True","title":"Before Save"},{"location":"models/callbacks/#before-update","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 use ORM::ActiveRecord::Model ; class Client is Model { submethod BUILD { self . validate: 'email' , { : presence }; self . before- update: -> { self . lowercase-email }; } method lowercase-email { self . email .= lc ; } } # Email is not lower-cased before the record is created my $client = Client . create ({ email => 'Fred@AOL.com' }); say $client . email eq 'Fred@AOL.com' ; # Email is lower-cased before the record is saved $client . save ; say $client . email eq 'fred@aol.com' ; Output 1 2 True True","title":"Before Update"},{"location":"models/models/","text":"Models ORM::ActiveRecord supports model relationships, the layer of your app that is responsible for managing data and business logic. Basic Example In this example the user has many pages and the reverse is also true, a page belongs to a `user. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 use ORM::ActiveRecord::Model ; class Page {...} # forward declaration class User is Model is export { submethod BUILD { self . has-many: pages => class => Page ; } } class Page is Model is export { submethod BUILD { self . belongs-to: user => class => User ; } } Perl 6 does single-pass compilation. You must provide forward declarations {...} for any models that have not been defined yet but need to be used in has-many or belongs-to relationships. This allows chaining method calls together like this: 1 2 3 4 5 my $user = User . create ({ fname => 'Greg' }); my $page = Page . create ({: $user , name => 'Rakuist' }); say $user . pages . first . name ; say $page . user . fname ; Output 1 2 Rakuist Greg Access to lower level foreign key relationships is supported. 1 say $page . user_id == $user . id ; Output 1 True Where Query To search for a particular record you can issue a where query with a hash for parameters. 1 2 3 4 5 6 7 8 9 10 11 12 13 use ORM::ActiveRecord::Model ; class User is Model { submethod BUILD { self . validate: 'fname' , { : presence } } } my $fred = User . create ({ fname => 'Fred' }); my $barney = User . create ({ fname => 'Barney' }); my $result = User . where ({ fname => 'Fred' }). first ; say $result == $fred ; Output 1 True Scope Frequently used queries can be made into a scope for easier access. Scopes live on the model type, not on an instance of the type, so we use $?CLASS to point to the existing class. The contents of the scope is a lazy block that is only evaluated when required. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 use ORM::ActiveRecord::Model ; class Image is Model { $?CLASS . scope: 'jpgs' , -> { $?CLASS . where ({ ext => 'jpg' }) } submethod BUILD { self . validate: 'name' , { : presence } self . validate: 'ext' , { : presence , inclusion => { in => <jpg png> } } } } my $foo = Image . create ({ name => 'foo' , ext => 'jpg' }); my $bar = Image . create ({ name => 'bar' , ext => 'jpg' }); my $baz = Image . create ({ name => 'baz' , ext => 'png' }); say Image . count ; my @images = Image . jpgs . all ; say any ( @images ) == $foo ; say any ( @images ) == $bar ; say none ( @images ) == $baz ; Output 1 2 3 4 3 True True True Has Many Through You can access related models using has-many with through . In this example a user has access to magazines through the subscriptions model: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Subscription {...} # stub class User is Model { submethod BUILD { self . has-many: subscriptions => class => Subscription ; self . has-many: magazines => through => : subscriptions ; } } class Magazine is Model {} class Subscription is Model { submethod BUILD { self . belongs-to: user => class => User ; self . belongs-to: magazine => class => Magazine ; } } my $user = User . create ({ fname => 'Greg' }); my $magazine = Magazine . create ({ title => 'Mad' }); Subscription . create ({: $user , : $magazine }); say $user . magazines . first == $magazine ; Output 1 True Is Dirty If you modify a record it will need to be persisted back to the database or the changes will eventually be lost. To know if you actually have pending changes that need to be saved you can call is-dirty on the model instance. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 use ORM::ActiveRecord::Model ; class User is Model { submethod BUILD { self . validate: 'fname' , { : presence } } } my $user = User . create ({ fname => 'Fred' }); say $user . is-dirty ; $user . fname = 'John' ; say $user . is-dirty ; $user . save ; say $user . is-dirty ; Output 1 2 3 False True False","title":"Info"},{"location":"models/models/#models","text":"ORM::ActiveRecord supports model relationships, the layer of your app that is responsible for managing data and business logic.","title":"Models"},{"location":"models/models/#basic-example","text":"In this example the user has many pages and the reverse is also true, a page belongs to a `user. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 use ORM::ActiveRecord::Model ; class Page {...} # forward declaration class User is Model is export { submethod BUILD { self . has-many: pages => class => Page ; } } class Page is Model is export { submethod BUILD { self . belongs-to: user => class => User ; } } Perl 6 does single-pass compilation. You must provide forward declarations {...} for any models that have not been defined yet but need to be used in has-many or belongs-to relationships. This allows chaining method calls together like this: 1 2 3 4 5 my $user = User . create ({ fname => 'Greg' }); my $page = Page . create ({: $user , name => 'Rakuist' }); say $user . pages . first . name ; say $page . user . fname ; Output 1 2 Rakuist Greg Access to lower level foreign key relationships is supported. 1 say $page . user_id == $user . id ; Output 1 True","title":"Basic Example"},{"location":"models/models/#where-query","text":"To search for a particular record you can issue a where query with a hash for parameters. 1 2 3 4 5 6 7 8 9 10 11 12 13 use ORM::ActiveRecord::Model ; class User is Model { submethod BUILD { self . validate: 'fname' , { : presence } } } my $fred = User . create ({ fname => 'Fred' }); my $barney = User . create ({ fname => 'Barney' }); my $result = User . where ({ fname => 'Fred' }). first ; say $result == $fred ; Output 1 True","title":"Where Query"},{"location":"models/models/#scope","text":"Frequently used queries can be made into a scope for easier access. Scopes live on the model type, not on an instance of the type, so we use $?CLASS to point to the existing class. The contents of the scope is a lazy block that is only evaluated when required. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 use ORM::ActiveRecord::Model ; class Image is Model { $?CLASS . scope: 'jpgs' , -> { $?CLASS . where ({ ext => 'jpg' }) } submethod BUILD { self . validate: 'name' , { : presence } self . validate: 'ext' , { : presence , inclusion => { in => <jpg png> } } } } my $foo = Image . create ({ name => 'foo' , ext => 'jpg' }); my $bar = Image . create ({ name => 'bar' , ext => 'jpg' }); my $baz = Image . create ({ name => 'baz' , ext => 'png' }); say Image . count ; my @images = Image . jpgs . all ; say any ( @images ) == $foo ; say any ( @images ) == $bar ; say none ( @images ) == $baz ; Output 1 2 3 4 3 True True True","title":"Scope"},{"location":"models/models/#has-many-through","text":"You can access related models using has-many with through . In this example a user has access to magazines through the subscriptions model: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Subscription {...} # stub class User is Model { submethod BUILD { self . has-many: subscriptions => class => Subscription ; self . has-many: magazines => through => : subscriptions ; } } class Magazine is Model {} class Subscription is Model { submethod BUILD { self . belongs-to: user => class => User ; self . belongs-to: magazine => class => Magazine ; } } my $user = User . create ({ fname => 'Greg' }); my $magazine = Magazine . create ({ title => 'Mad' }); Subscription . create ({: $user , : $magazine }); say $user . magazines . first == $magazine ; Output 1 True","title":"Has Many Through"},{"location":"models/models/#is-dirty","text":"If you modify a record it will need to be persisted back to the database or the changes will eventually be lost. To know if you actually have pending changes that need to be saved you can call is-dirty on the model instance. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 use ORM::ActiveRecord::Model ; class User is Model { submethod BUILD { self . validate: 'fname' , { : presence } } } my $user = User . create ({ fname => 'Fred' }); say $user . is-dirty ; $user . fname = 'John' ; say $user . is-dirty ; $user . save ; say $user . is-dirty ; Output 1 2 3 False True False","title":"Is Dirty"},{"location":"validations/conditionals/","text":"Validation Conditionals Validations can be made conditional based on some other method call or criteria. The available conditionals are if , unless , and on . With on a create or update life cycle event may be specified. If 1 2 3 4 5 6 7 8 9 10 11 12 13 use ORM::ActiveRecord::Model ; class Book is Model { submethod BUILD { self . validate: 'title' , { : presence , : if => { self . returns-true } } } method returns-true { True } } my $book = Book . build ; say $book . is-valid ; say $book . errors . title [ 0 ]; Output 1 2 False must be present Unless 1 2 3 4 5 6 7 8 9 10 11 12 13 use ORM::ActiveRecord::Model ; class Book is Model { submethod BUILD { self . validate: 'title' , { : presence , : unless => { self . returns-false } } } method returns-false { False } } my $book = Book . build ; say $book . is-valid ; say $book . errors . title [ 0 ]; Output 1 2 False must be present On Create 1 2 3 4 5 6 7 8 9 10 11 use ORM::ActiveRecord::Model ; class User is Model { submethod BUILD { self . validate: 'fname' , { : presence , on => { : create } } } } my $user = User . create ({}); say $user . is-valid ; say $user . errors . fname [ 0 ]; Output 1 2 False must be present Update 1 2 3 4 5 6 7 8 9 10 11 12 13 14 use ORM::ActiveRecord::Model ; class User is Model { submethod BUILD { self . validate: 'fname' , { : presence , on => { : update } } } } my $user = User . create ({}); say $user . is-valid ; $user . update ({ fname => '' }); say $user . is-valid ; say $user . errors . fname [ 0 ]; Output 1 2 3 True False must be present","title":"Conditionals"},{"location":"validations/conditionals/#validation-conditionals","text":"Validations can be made conditional based on some other method call or criteria. The available conditionals are if , unless , and on . With on a create or update life cycle event may be specified.","title":"Validation Conditionals"},{"location":"validations/conditionals/#if","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 use ORM::ActiveRecord::Model ; class Book is Model { submethod BUILD { self . validate: 'title' , { : presence , : if => { self . returns-true } } } method returns-true { True } } my $book = Book . build ; say $book . is-valid ; say $book . errors . title [ 0 ]; Output 1 2 False must be present","title":"If"},{"location":"validations/conditionals/#unless","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 use ORM::ActiveRecord::Model ; class Book is Model { submethod BUILD { self . validate: 'title' , { : presence , : unless => { self . returns-false } } } method returns-false { False } } my $book = Book . build ; say $book . is-valid ; say $book . errors . title [ 0 ]; Output 1 2 False must be present","title":"Unless"},{"location":"validations/conditionals/#on","text":"","title":"On"},{"location":"validations/conditionals/#create","text":"1 2 3 4 5 6 7 8 9 10 11 use ORM::ActiveRecord::Model ; class User is Model { submethod BUILD { self . validate: 'fname' , { : presence , on => { : create } } } } my $user = User . create ({}); say $user . is-valid ; say $user . errors . fname [ 0 ]; Output 1 2 False must be present","title":"Create"},{"location":"validations/conditionals/#update","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 use ORM::ActiveRecord::Model ; class User is Model { submethod BUILD { self . validate: 'fname' , { : presence , on => { : update } } } } my $user = User . create ({}); say $user . is-valid ; $user . update ({ fname => '' }); say $user . is-valid ; say $user . errors . fname [ 0 ]; Output 1 2 3 True False must be present","title":"Update"},{"location":"validations/data/","text":"Data Validations ORM::ActiveRecord supports many forms of data validations, when they occur and if they occur at all. Acceptance The acceptance validation requires a field value to be True for the Model instance to be valid. 1 2 3 4 5 6 7 use ORM::ActiveRecord::Model ; class Contract is Model { submethod BUILD { self . validate: 'terms' , { : acceptance } } } A value of False will make the instance invalid and the validated field will contain an error. 1 2 3 my $contract = Contract . create ({ name => 'Offical Document' , terms => False }); say $contract . is-valid ; say $contract . errors . terms [ 0 ]; Output 1 2 False must be accepted Confirmation The confirmation validation requires a field to be \"confirmed\" for the Model instance to be valid. A virtual field with a suffix of \"_confirmed\" is required. Combining confirmation with presence is usually helpful. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 use ORM::ActiveRecord::Model ; class Client is Model { submethod BUILD { self . validate: 'email' , { : presence , : confirmation } } } my $client = Client . build ({ email => 'fred@aol.com' }); say $client . is-invalid ; say $client . errors . email [ 0 ]; $client = Client . build ({ email => 'fred@aol.com' , email_confirmation => 'fred@aol.com' }); say $client . is-valid ; Output 1 2 3 False must be confirmed True Exclusion The exclusion validation prevents certain values from being entered. The excluded values are defined using in . 1 2 3 4 5 6 7 8 9 10 11 use ORM::ActiveRecord::Model ; class Person is Model { submethod BUILD { self . validate: 'username' , { exclusion => { in => <admin superuser> } } } } my $person = Person . build ({ username => 'admin' }); say $person . is-valid ; say $person . errors . username [ 0 ]; Output 1 2 False is invalid Format The format validation requires a field value match a specific regular expression. The format is defined using with . 1 2 3 4 5 6 7 8 9 10 11 use ORM::ActiveRecord::Model ; class Contact is Model { submethod BUILD { self . validate: 'email' , { format => { with => /: i ^ <[\\w]> + '@' <[\\w]> + '.' <[\\w]> + $/ } } } } my $contact = Contact . create ({ email => 'foo' }); say $contact . is-valid ; say $contact . errors . email [ 0 ]; Output 1 2 False is invalid Inclusion The inclusion validation requires a field value exist in a list of pre-defined values. The allowed values are defined using in . 1 2 3 4 5 6 7 8 9 10 11 use ORM::ActiveRecord::Model ; class Image is Model { submethod BUILD { self . validate: 'format' , { inclusion => { in => <gif jpeg jpg png> } } } } my $image = Image . build ({ format => 'foo' }); say $image . is-invalid ; say $image . errors . format [ 0 ]; Output 1 2 False is invalid Length The length validation requires a field value to be a certain length to be valid. Valid values are defined using min , max , is , or in . Minimum A min length validation requires the length of the field value be a specified minimum: 1 2 3 4 5 6 7 8 9 10 11 use ORM::ActiveRecord::Model ; class User is Model { submethod BUILD { self . validate: 'fname' , { length => { min => 4 } } } } my $user = User . build ({ fname => 'Joe' }); say $user . is-valid ; say $user . errors . fname [ 0 ]; Output 1 2 False at least 4 characters required Maximum A max length validation requires a field value length be less than a specified value. 1 2 3 4 5 6 7 8 9 10 11 use ORM::ActiveRecord::Model ; class User is Model { submethod BUILD { self . validate: 'fname' , { length => { max => 12 } } } } my $user = User . build ({ fname => 'Michaelangelo' }); say $user . is-valid ; say $user . errors . fname [ 0 ]; Output 1 2 False only 12 characters allowed In a range An in length validation requires the field value length be within a specified range. 1 2 3 4 5 6 7 8 9 10 11 use ORM::ActiveRecord::Model ; class User is Model { submethod BUILD { self . validate: 'fname' , { length => { in => 4 .. 32 } } } } my $user = User . build ({ fname => 'Joe' }); say $user . is-valid ; say $user . errors . fname [ 0 ]; Output 1 2 False 4 to 32 characters required Is exactly An is length validation requires a value be an exact size: 1 2 3 4 5 6 7 8 9 10 11 use ORM::ActiveRecord::Model ; class User is Model { submethod BUILD { self . validate: 'fname' , { length => { is => 8 } } } } my $user = User . build ({ fname => 'Joe' }); say $user . is-valid ; say $user . errors . fname [ 0 ]; Output 1 2 False exactly 8 characters required Numericality The numericality validation requires a field value to be numerical and of a specific value or in a specific range. Values can be specified using gt , gte , lt , lte , as well as in for ranges. Less than 1 2 3 4 5 6 7 8 9 10 11 use ORM::ActiveRecord::Model ; class Book is Model { submethod BUILD { self . validate: 'pages' , { numericality => { lt => 400 } } } } my $book = Book . create ({ pages => 400 }); say $book . is-valid ; say $book . errors . pages [ 0 ]; Output 1 2 False less than 400 required Less than or equal 1 2 3 4 5 6 7 8 9 10 11 use ORM::ActiveRecord::Model ; class Book is Model { submethod BUILD { self . validate: 'pages' , { numericality => { lte => 400 } } } } my $book = Book . create ({ pages => 401 }); say $book . is-valid ; say $book . errors . pages [ 0 ]; Output 1 2 False 400 or less required Greater than 1 2 3 4 5 6 7 8 9 10 11 use ORM::ActiveRecord::Model ; class Book is Model { submethod BUILD { self . validate: 'pages' , { numericality => { gt => 400 } } } } my $book = Book . create ({ pages => 400 }); say $book . is-valid ; say $book . errors . pages [ 0 ]; Output 1 2 False more than 400 required Greater than or equal 1 2 3 4 5 6 7 8 9 10 11 use ORM::ActiveRecord::Model ; class Book is Model { submethod BUILD { self . validate: 'pages' , { numericality => { gte => 400 } } } } my $book = Book . create ({ pages => 399 }); say $book . is-valid ; say $book . errors . pages [ 0 ]; Output 1 2 False 400 or more required In a range 1 2 3 4 5 6 7 8 9 10 11 use ORM::ActiveRecord::Model ; class Book is Model { submethod BUILD { self . validate: 'pages' , { numericality => { in => 400 .. 1000 } } } } my $book = Book . create ({ pages => 399 }); say $book . is-valid ; say $book . errors . pages [ 0 ]; Output 1 2 False 400 to 1000 required Presence The presence validation requires a field value to simply exist for the Model instance to be valid. 1 2 3 4 5 6 7 8 9 10 11 use ORM::ActiveRecord::Model ; class User is Model { submethod BUILD { self . validate: 'fname' , { : presence } } } my $user = User . build ; say $user . is-valid ; say $user . errors . fname [ 0 ]; Output 1 2 False must be present Uniqueness The uniqueness validation requires a field value to be unique with respect to existing field value data in the database. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 use ORM::ActiveRecord::Model ; class Person is Model { submethod BUILD { self . validate: 'username' , { : uniqueness } } } my $person = Person . create ({ username => 'alfred' }); say $person . is-valid ; my $person_2 = Person . build ({ username => 'alfred' }); say $person_2 . is-valid ; say $person_2 . errors . username [ 0 ]; Output 1 2 3 True False must be unique Unique Scope The uniqueness validation can also contain a scope. This, for example, can be used for validating uniqueness within a specific foreign key. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 use ORM::ActiveRecord::Model ; class Subscription {...} class User is Model { submethod BUILD { self . has-many: subscriptions => class => Subscription ; self . validate: 'fname' , { : presence } } } class Magazine is Model { submethod BUILD { self . has-many: subscriptions => class => Subscription ; self . validate: 'title' , { : presence } } } class Subscription is Model { submethod BUILD { self . belongs-to: user => class => User ; self . belongs-to: magazine => class => Magazine ; self . validate: 'user_id' , { uniqueness => scope => : magazine_id } } } my $user = User . create ({ fname => 'Greg' }); my $magazine = Magazine . create ({ title => 'Mad' }); my $subscription = Subscription . create ({: $user , : $magazine }); say $subscription . is-valid ; my $subscription_2 = Subscription . build ({: $user , : $magazine }); say $subscription_2 . is-valid ; say $subscription_2 . errors . user_id [ 0 ]; Output 1 2 3 True False must be unique","title":"Data"},{"location":"validations/data/#data-validations","text":"ORM::ActiveRecord supports many forms of data validations, when they occur and if they occur at all.","title":"Data Validations"},{"location":"validations/data/#acceptance","text":"The acceptance validation requires a field value to be True for the Model instance to be valid. 1 2 3 4 5 6 7 use ORM::ActiveRecord::Model ; class Contract is Model { submethod BUILD { self . validate: 'terms' , { : acceptance } } } A value of False will make the instance invalid and the validated field will contain an error. 1 2 3 my $contract = Contract . create ({ name => 'Offical Document' , terms => False }); say $contract . is-valid ; say $contract . errors . terms [ 0 ]; Output 1 2 False must be accepted","title":"Acceptance"},{"location":"validations/data/#confirmation","text":"The confirmation validation requires a field to be \"confirmed\" for the Model instance to be valid. A virtual field with a suffix of \"_confirmed\" is required. Combining confirmation with presence is usually helpful. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 use ORM::ActiveRecord::Model ; class Client is Model { submethod BUILD { self . validate: 'email' , { : presence , : confirmation } } } my $client = Client . build ({ email => 'fred@aol.com' }); say $client . is-invalid ; say $client . errors . email [ 0 ]; $client = Client . build ({ email => 'fred@aol.com' , email_confirmation => 'fred@aol.com' }); say $client . is-valid ; Output 1 2 3 False must be confirmed True","title":"Confirmation"},{"location":"validations/data/#exclusion","text":"The exclusion validation prevents certain values from being entered. The excluded values are defined using in . 1 2 3 4 5 6 7 8 9 10 11 use ORM::ActiveRecord::Model ; class Person is Model { submethod BUILD { self . validate: 'username' , { exclusion => { in => <admin superuser> } } } } my $person = Person . build ({ username => 'admin' }); say $person . is-valid ; say $person . errors . username [ 0 ]; Output 1 2 False is invalid","title":"Exclusion"},{"location":"validations/data/#format","text":"The format validation requires a field value match a specific regular expression. The format is defined using with . 1 2 3 4 5 6 7 8 9 10 11 use ORM::ActiveRecord::Model ; class Contact is Model { submethod BUILD { self . validate: 'email' , { format => { with => /: i ^ <[\\w]> + '@' <[\\w]> + '.' <[\\w]> + $/ } } } } my $contact = Contact . create ({ email => 'foo' }); say $contact . is-valid ; say $contact . errors . email [ 0 ]; Output 1 2 False is invalid","title":"Format"},{"location":"validations/data/#inclusion","text":"The inclusion validation requires a field value exist in a list of pre-defined values. The allowed values are defined using in . 1 2 3 4 5 6 7 8 9 10 11 use ORM::ActiveRecord::Model ; class Image is Model { submethod BUILD { self . validate: 'format' , { inclusion => { in => <gif jpeg jpg png> } } } } my $image = Image . build ({ format => 'foo' }); say $image . is-invalid ; say $image . errors . format [ 0 ]; Output 1 2 False is invalid","title":"Inclusion"},{"location":"validations/data/#length","text":"The length validation requires a field value to be a certain length to be valid. Valid values are defined using min , max , is , or in .","title":"Length"},{"location":"validations/data/#minimum","text":"A min length validation requires the length of the field value be a specified minimum: 1 2 3 4 5 6 7 8 9 10 11 use ORM::ActiveRecord::Model ; class User is Model { submethod BUILD { self . validate: 'fname' , { length => { min => 4 } } } } my $user = User . build ({ fname => 'Joe' }); say $user . is-valid ; say $user . errors . fname [ 0 ]; Output 1 2 False at least 4 characters required","title":"Minimum"},{"location":"validations/data/#maximum","text":"A max length validation requires a field value length be less than a specified value. 1 2 3 4 5 6 7 8 9 10 11 use ORM::ActiveRecord::Model ; class User is Model { submethod BUILD { self . validate: 'fname' , { length => { max => 12 } } } } my $user = User . build ({ fname => 'Michaelangelo' }); say $user . is-valid ; say $user . errors . fname [ 0 ]; Output 1 2 False only 12 characters allowed","title":"Maximum"},{"location":"validations/data/#in-a-range","text":"An in length validation requires the field value length be within a specified range. 1 2 3 4 5 6 7 8 9 10 11 use ORM::ActiveRecord::Model ; class User is Model { submethod BUILD { self . validate: 'fname' , { length => { in => 4 .. 32 } } } } my $user = User . build ({ fname => 'Joe' }); say $user . is-valid ; say $user . errors . fname [ 0 ]; Output 1 2 False 4 to 32 characters required","title":"In a range"},{"location":"validations/data/#is-exactly","text":"An is length validation requires a value be an exact size: 1 2 3 4 5 6 7 8 9 10 11 use ORM::ActiveRecord::Model ; class User is Model { submethod BUILD { self . validate: 'fname' , { length => { is => 8 } } } } my $user = User . build ({ fname => 'Joe' }); say $user . is-valid ; say $user . errors . fname [ 0 ]; Output 1 2 False exactly 8 characters required","title":"Is exactly"},{"location":"validations/data/#numericality","text":"The numericality validation requires a field value to be numerical and of a specific value or in a specific range. Values can be specified using gt , gte , lt , lte , as well as in for ranges.","title":"Numericality"},{"location":"validations/data/#less-than","text":"1 2 3 4 5 6 7 8 9 10 11 use ORM::ActiveRecord::Model ; class Book is Model { submethod BUILD { self . validate: 'pages' , { numericality => { lt => 400 } } } } my $book = Book . create ({ pages => 400 }); say $book . is-valid ; say $book . errors . pages [ 0 ]; Output 1 2 False less than 400 required","title":"Less than"},{"location":"validations/data/#less-than-or-equal","text":"1 2 3 4 5 6 7 8 9 10 11 use ORM::ActiveRecord::Model ; class Book is Model { submethod BUILD { self . validate: 'pages' , { numericality => { lte => 400 } } } } my $book = Book . create ({ pages => 401 }); say $book . is-valid ; say $book . errors . pages [ 0 ]; Output 1 2 False 400 or less required","title":"Less than or equal"},{"location":"validations/data/#greater-than","text":"1 2 3 4 5 6 7 8 9 10 11 use ORM::ActiveRecord::Model ; class Book is Model { submethod BUILD { self . validate: 'pages' , { numericality => { gt => 400 } } } } my $book = Book . create ({ pages => 400 }); say $book . is-valid ; say $book . errors . pages [ 0 ]; Output 1 2 False more than 400 required","title":"Greater than"},{"location":"validations/data/#greater-than-or-equal","text":"1 2 3 4 5 6 7 8 9 10 11 use ORM::ActiveRecord::Model ; class Book is Model { submethod BUILD { self . validate: 'pages' , { numericality => { gte => 400 } } } } my $book = Book . create ({ pages => 399 }); say $book . is-valid ; say $book . errors . pages [ 0 ]; Output 1 2 False 400 or more required","title":"Greater than or equal"},{"location":"validations/data/#in-a-range_1","text":"1 2 3 4 5 6 7 8 9 10 11 use ORM::ActiveRecord::Model ; class Book is Model { submethod BUILD { self . validate: 'pages' , { numericality => { in => 400 .. 1000 } } } } my $book = Book . create ({ pages => 399 }); say $book . is-valid ; say $book . errors . pages [ 0 ]; Output 1 2 False 400 to 1000 required","title":"In a range"},{"location":"validations/data/#presence","text":"The presence validation requires a field value to simply exist for the Model instance to be valid. 1 2 3 4 5 6 7 8 9 10 11 use ORM::ActiveRecord::Model ; class User is Model { submethod BUILD { self . validate: 'fname' , { : presence } } } my $user = User . build ; say $user . is-valid ; say $user . errors . fname [ 0 ]; Output 1 2 False must be present","title":"Presence"},{"location":"validations/data/#uniqueness","text":"The uniqueness validation requires a field value to be unique with respect to existing field value data in the database. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 use ORM::ActiveRecord::Model ; class Person is Model { submethod BUILD { self . validate: 'username' , { : uniqueness } } } my $person = Person . create ({ username => 'alfred' }); say $person . is-valid ; my $person_2 = Person . build ({ username => 'alfred' }); say $person_2 . is-valid ; say $person_2 . errors . username [ 0 ]; Output 1 2 3 True False must be unique","title":"Uniqueness"},{"location":"validations/data/#unique-scope","text":"The uniqueness validation can also contain a scope. This, for example, can be used for validating uniqueness within a specific foreign key. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 use ORM::ActiveRecord::Model ; class Subscription {...} class User is Model { submethod BUILD { self . has-many: subscriptions => class => Subscription ; self . validate: 'fname' , { : presence } } } class Magazine is Model { submethod BUILD { self . has-many: subscriptions => class => Subscription ; self . validate: 'title' , { : presence } } } class Subscription is Model { submethod BUILD { self . belongs-to: user => class => User ; self . belongs-to: magazine => class => Magazine ; self . validate: 'user_id' , { uniqueness => scope => : magazine_id } } } my $user = User . create ({ fname => 'Greg' }); my $magazine = Magazine . create ({ title => 'Mad' }); my $subscription = Subscription . create ({: $user , : $magazine }); say $subscription . is-valid ; my $subscription_2 = Subscription . build ({: $user , : $magazine }); say $subscription_2 . is-valid ; say $subscription_2 . errors . user_id [ 0 ]; Output 1 2 3 True False must be unique","title":"Unique Scope"}]}